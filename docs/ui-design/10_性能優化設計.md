# BandPro æ€§èƒ½å„ªåŒ–è¨­è¨ˆ

å‰ç«¯æ€§èƒ½å„ªåŒ–èˆ‡ç”¨æˆ¶é«”é©—æå‡çš„å®Œæ•´è¨­è¨ˆè¦ç¯„

## âš¡ æ€§èƒ½å„ªåŒ–æ¶æ§‹

### æ€§èƒ½å„ªåŒ–å±¤æ¬¡
```mermaid
flowchart TD
    subgraph PerformanceOptimization[æ€§èƒ½å„ªåŒ–å±¤æ¬¡]
        subgraph LoadingLayer[è¼‰å…¥å„ªåŒ–å±¤]
            LazyLoading[æ‡¶è¼‰å…¥<br/>æŒ‰éœ€è¼‰å…¥çµ„ä»¶]
            CodeSplitting[ä»£ç¢¼åˆ†å‰²<br/>è·¯ç”±ç´šåˆ†å‰²]
            ResourcePreload[è³‡æºé è¼‰<br/>é—œéµè³‡æºå„ªå…ˆ]
        end
        
        subgraph RenderingLayer[æ¸²æŸ“å„ªåŒ–å±¤]
            VirtualScrolling[è™›æ“¬æ»¾å‹•<br/>å¤§åˆ—è¡¨å„ªåŒ–]
            ComponentMemo[çµ„ä»¶è¨˜æ†¶<br/>é¿å…é‡è¤‡æ¸²æŸ“]
            DOMOptimization[DOMå„ªåŒ–<br/>æœ€å°åŒ–DOMæ“ä½œ]
        end
        
        subgraph DataLayer[æ•¸æ“šå„ªåŒ–å±¤]
            StateManagement[ç‹€æ…‹ç®¡ç†<br/>æœ€å°åŒ–ç‹€æ…‹æ›´æ–°]
            DataCaching[æ•¸æ“šå¿«å–<br/>è«‹æ±‚çµæœå¿«å–]
            LocalStorage[æœ¬åœ°å­˜å„²<br/>é›¢ç·šæ•¸æ“šæ”¯æ´]
        end
        
        subgraph NetworkLayer[ç¶²è·¯å„ªåŒ–å±¤]
            RequestBatching[è«‹æ±‚æ‰¹è™•ç†<br/>æ¸›å°‘ç¶²è·¯è«‹æ±‚]
            ImageOptimization[åœ–ç‰‡å„ªåŒ–<br/>æ ¼å¼è½‰æ›å£“ç¸®]
            CDNDelivery[CDNé…é€<br/>å…¨çƒå…§å®¹åˆ†ç™¼]
        end
    end
    
    LazyLoading --> VirtualScrolling
    CodeSplitting --> ComponentMemo
    ResourcePreload --> DOMOptimization
    
    VirtualScrolling --> StateManagement
    ComponentMemo --> DataCaching
    DOMOptimization --> LocalStorage
    
    StateManagement --> RequestBatching
    DataCaching --> ImageOptimization
    LocalStorage --> CDNDelivery
```

### éŸ³æ¨‚ç·¨è¼¯å™¨å°ˆç”¨å„ªåŒ–
```mermaid
mindmap
  root((éŸ³æ¨‚ç·¨è¼¯å™¨å„ªåŒ–))
    éŸ³ç¬¦æ¸²æŸ“
      SVGå„ªåŒ–
        è·¯å¾‘ç°¡åŒ–
        ç¾¤çµ„åˆä½µ
        æ¨£å¼å…§è¯
      Canvasæ¸²æŸ“
        é›¢å±æ¸²æŸ“
        æ‰¹é‡ç¹ªè£½
        å¢é‡æ›´æ–°
    å³æ™‚å”ä½œ
      WebSocketå„ªåŒ–
        é€£æ¥æ± ç®¡ç†
        è¨Šæ¯æ‰¹è™•ç†
        æ–·ç·šé‡é€£
      è¡çªè§£æ±º
        æ“ä½œè½‰æ›
        ç‰ˆæœ¬å‘é‡
        å¿«ç…§åŒæ­¥
    éŸ³é »è™•ç†
      Web Audio API
        éŸ³é »ä¸Šä¸‹æ–‡
        ç·©è¡å€ç®¡ç†
        æ•ˆæœéˆå„ªåŒ–
      MIDIæ”¯æ´
        è¨­å‚™æª¢æ¸¬
        è¨Šæ¯è™•ç†
        å»¶é²æœ€ä½³åŒ–
    è¨˜æ†¶é«”ç®¡ç†
      å°è±¡æ± 
        éŸ³ç¬¦å°è±¡æ± 
        äº‹ä»¶å°è±¡æ± 
        DOMç¯€é»æ± 
      åƒåœ¾å›æ”¶
        WeakMapä½¿ç”¨
        å¾ªç’°å¼•ç”¨é¿å…
        å®šæœŸæ¸…ç†
```

---

## ğŸš€ è¼‰å…¥æ€§èƒ½å„ªåŒ–

### æ‡¶è¼‰å…¥èˆ‡ä»£ç¢¼åˆ†å‰²
```typescript
// router/index.ts - è·¯ç”±ç´šä»£ç¢¼åˆ†å‰²
import { createRouter, createWebHistory } from 'vue-router'

const router = createRouter({
  history: createWebHistory(),
  routes: [
    {
      path: '/',
      name: 'Home',
      component: () => import('../views/HomePage.vue')
    },
    {
      path: '/editor',
      name: 'Editor',
      component: () => import('../views/EditorPage.vue'),
      // ç·¨è¼¯å™¨éœ€è¦é¡å¤–çš„ä¾è³´
      meta: { 
        requiresAuth: true,
        preload: ['music-notation-lib', 'audio-engine']
      }
    },
    {
      path: '/library',
      name: 'Library', 
      component: () => import('../views/LibraryPage.vue'),
      children: [
        {
          path: 'search',
          component: () => import('../views/library/SearchPage.vue')
        },
        {
          path: 'browse/:category',
          component: () => import('../views/library/BrowsePage.vue')
        }
      ]
    }
  ]
})

// è·¯ç”±é è¼‰å…¥
router.beforeResolve(async (to, from, next) => {
  if (to.meta?.preload) {
    const preloadPromises = to.meta.preload.map((module: string) => {
      switch (module) {
        case 'music-notation-lib':
          return import('../utils/musicNotation')
        case 'audio-engine':
          return import('../utils/audioEngine')
        default:
          return Promise.resolve()
      }
    })
    
    try {
      await Promise.all(preloadPromises)
    } catch (error) {
      console.error('é è¼‰å…¥æ¨¡çµ„å¤±æ•—:', error)
    }
  }
  
  next()
})

export default router
```

### çµ„ä»¶æ‡¶è¼‰å…¥ç­–ç•¥
```vue
<!-- components/LazyLoadWrapper.vue -->
<template>
  <div ref="wrapper" class="lazy-load-wrapper">
    <!-- è¼‰å…¥ä¸­ç‹€æ…‹ -->
    <div v-if="loading" class="loading-placeholder">
      <div class="loading-skeleton">
        <div class="skeleton-header"></div>
        <div class="skeleton-content"></div>
        <div class="skeleton-footer"></div>
      </div>
    </div>
    
    <!-- éŒ¯èª¤ç‹€æ…‹ -->
    <div v-else-if="error" class="error-state">
      <ExclamationTriangleIcon class="error-icon" />
      <p class="error-message">è¼‰å…¥å¤±æ•—</p>
      <button @click="retry" class="retry-button">é‡è©¦</button>
    </div>
    
    <!-- å¯¦éš›çµ„ä»¶ -->
    <Suspense v-else>
      <component :is="lazyComponent" v-bind="componentProps" />
      <template #fallback>
        <div class="component-loading">
          <div class="spinner"></div>
        </div>
      </template>
    </Suspense>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, defineAsyncComponent } from 'vue'
import { ExclamationTriangleIcon } from '@heroicons/vue/24/outline'

interface Props {
  componentPath: string
  componentProps?: Record<string, any>
  threshold?: number
  rootMargin?: string
}

const props = withDefaults(defineProps<Props>(), {
  threshold: 0.1,
  rootMargin: '50px'
})

const wrapper = ref<HTMLElement>()
const loading = ref(false)
const error = ref(false)
const lazyComponent = ref()

// å»ºç«‹ Intersection Observer
const createObserver = () => {
  return new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting && !lazyComponent.value && !loading.value) {
          loadComponent()
        }
      })
    },
    {
      threshold: props.threshold,
      rootMargin: props.rootMargin
    }
  )
}

// è¼‰å…¥çµ„ä»¶
const loadComponent = async () => {
  loading.value = true
  error.value = false
  
  try {
    // å‹•æ…‹å°å…¥çµ„ä»¶
    lazyComponent.value = defineAsyncComponent({
      loader: () => import(/* @vite-ignore */ props.componentPath),
      loadingComponent: () => null, // ä½¿ç”¨å¤–éƒ¨è¼‰å…¥ç‹€æ…‹
      errorComponent: () => null,   // ä½¿ç”¨å¤–éƒ¨éŒ¯èª¤ç‹€æ…‹
      delay: 200,
      timeout: 10000
    })
  } catch (err) {
    error.value = true
    console.error('çµ„ä»¶è¼‰å…¥å¤±æ•—:', err)
  } finally {
    loading.value = false
  }
}

// é‡è©¦è¼‰å…¥
const retry = () => {
  error.value = false
  loadComponent()
}

onMounted(() => {
  const observer = createObserver()
  if (wrapper.value) {
    observer.observe(wrapper.value)
  }
  
  // æ¸…ç†è§€å¯Ÿè€…
  return () => {
    observer.disconnect()
  }
})
</script>

<style scoped>
.lazy-load-wrapper {
  @apply min-h-32;
}

/* è¼‰å…¥éª¨æ¶å± */
.loading-skeleton {
  @apply space-y-4 p-4;
}

.skeleton-header,
.skeleton-content,
.skeleton-footer {
  @apply bg-gray-200 dark:bg-gray-700;
  @apply animate-pulse rounded;
}

.skeleton-header {
  @apply h-6 w-3/4;
}

.skeleton-content {
  @apply h-24 w-full;
}

.skeleton-footer {
  @apply h-4 w-1/2;
}

/* éŒ¯èª¤ç‹€æ…‹ */
.error-state {
  @apply flex flex-col items-center justify-center;
  @apply p-8 text-center;
}

.error-icon {
  @apply w-12 h-12 text-red-500 mb-4;
}

.error-message {
  @apply text-gray-600 dark:text-gray-400 mb-4;
}

.retry-button {
  @apply px-4 py-2;
  @apply bg-blue-500 hover:bg-blue-600;
  @apply text-white rounded-md;
  @apply transition-colors duration-200;
}

/* çµ„ä»¶è¼‰å…¥ä¸­ */
.component-loading {
  @apply flex items-center justify-center p-8;
}

.spinner {
  @apply w-8 h-8;
  @apply border-4 border-blue-500 border-t-transparent;
  @apply rounded-full animate-spin;
}
</style>
```

---

## ğŸ¯ æ¸²æŸ“æ€§èƒ½å„ªåŒ–

### è™›æ“¬æ»¾å‹•å¯¦ç¾
```vue
<!-- components/VirtualScroll.vue -->
<template>
  <div 
    ref="scrollContainer"
    class="virtual-scroll-container"
    @scroll="handleScroll"
  >
    <!-- ä¸Šæ–¹å¡«å…… -->
    <div 
      class="spacer"
      :style="{ height: `${offsetTop}px` }"
    ></div>
    
    <!-- å¯è¦‹é …ç›® -->
    <div 
      v-for="item in visibleItems"
      :key="getItemKey(item)"
      class="virtual-item"
      :style="getItemStyle(item)"
    >
      <slot :item="item" :index="item.index">
        {{ item.data }}
      </slot>
    </div>
    
    <!-- ä¸‹æ–¹å¡«å…… -->
    <div 
      class="spacer"
      :style="{ height: `${offsetBottom}px` }"
    ></div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, watch } from 'vue'

interface VirtualItem {
  index: number
  data: any
  height?: number
  top?: number
}

interface Props {
  items: any[]
  itemHeight: number | ((item: any, index: number) => number)
  containerHeight: number
  overscan?: number
  keyField?: string
}

const props = withDefaults(defineProps<Props>(), {
  overscan: 5,
  keyField: 'id'
})

const scrollContainer = ref<HTMLElement>()
const scrollTop = ref(0)
const containerHeight = ref(0)

// è¨ˆç®—é …ç›®ä½ç½®
const itemPositions = computed(() => {
  const positions: Array<{ top: number; height: number }> = []
  let top = 0
  
  props.items.forEach((item, index) => {
    const height = typeof props.itemHeight === 'function' 
      ? props.itemHeight(item, index)
      : props.itemHeight
    
    positions.push({ top, height })
    top += height
  })
  
  return positions
})

// ç¸½é«˜åº¦
const totalHeight = computed(() => {
  const lastPosition = itemPositions.value[itemPositions.value.length - 1]
  return lastPosition ? lastPosition.top + lastPosition.height : 0
})

// å¯è¦‹ç¯„åœ
const visibleRange = computed(() => {
  const start = Math.max(0, 
    itemPositions.value.findIndex(pos => 
      pos.top + pos.height > scrollTop.value
    ) - props.overscan
  )
  
  const end = Math.min(props.items.length - 1,
    itemPositions.value.findLastIndex(pos => 
      pos.top < scrollTop.value + containerHeight.value
    ) + props.overscan
  )
  
  return { start, end }
})

// å¯è¦‹é …ç›®
const visibleItems = computed(() => {
  const { start, end } = visibleRange.value
  const items: VirtualItem[] = []
  
  for (let i = start; i <= end; i++) {
    if (props.items[i]) {
      items.push({
        index: i,
        data: props.items[i],
        height: itemPositions.value[i]?.height,
        top: itemPositions.value[i]?.top
      })
    }
  }
  
  return items
})

// ä¸Šæ–¹åç§»
const offsetTop = computed(() => {
  const { start } = visibleRange.value
  return start > 0 ? itemPositions.value[start]?.top || 0 : 0
})

// ä¸‹æ–¹åç§»
const offsetBottom = computed(() => {
  const { end } = visibleRange.value
  const lastVisibleTop = itemPositions.value[end]?.top || 0
  const lastVisibleHeight = itemPositions.value[end]?.height || 0
  return Math.max(0, totalHeight.value - lastVisibleTop - lastVisibleHeight)
})

// äº‹ä»¶è™•ç†
const handleScroll = () => {
  if (scrollContainer.value) {
    scrollTop.value = scrollContainer.value.scrollTop
  }
}

// ç²å–é …ç›®éµå€¼
const getItemKey = (item: VirtualItem) => {
  if (props.keyField && item.data[props.keyField]) {
    return item.data[props.keyField]
  }
  return item.index
}

// ç²å–é …ç›®æ¨£å¼
const getItemStyle = (item: VirtualItem) => {
  return {
    position: 'absolute' as const,
    top: `${item.top}px`,
    height: `${item.height}px`,
    width: '100%'
  }
}

// æ»¾å‹•åˆ°æŒ‡å®šé …ç›®
const scrollToItem = (index: number, alignment: 'start' | 'center' | 'end' = 'start') => {
  if (!scrollContainer.value || !itemPositions.value[index]) return
  
  const itemPosition = itemPositions.value[index]
  let scrollTo: number
  
  switch (alignment) {
    case 'start':
      scrollTo = itemPosition.top
      break
    case 'center':
      scrollTo = itemPosition.top + (itemPosition.height - containerHeight.value) / 2
      break
    case 'end':
      scrollTo = itemPosition.top + itemPosition.height - containerHeight.value
      break
  }
  
  scrollContainer.value.scrollTo({
    top: Math.max(0, Math.min(scrollTo, totalHeight.value - containerHeight.value)),
    behavior: 'smooth'
  })
}

// éŸ¿æ‡‰å¼èª¿æ•´
const updateContainerHeight = () => {
  if (scrollContainer.value) {
    containerHeight.value = scrollContainer.value.clientHeight
  }
}

// ç¯€æµæ»¾å‹•äº‹ä»¶
let scrollTimeout: number
const throttledScroll = () => {
  if (scrollTimeout) {
    cancelAnimationFrame(scrollTimeout)
  }
  
  scrollTimeout = requestAnimationFrame(handleScroll)
}

onMounted(() => {
  updateContainerHeight()
  window.addEventListener('resize', updateContainerHeight)
  
  if (scrollContainer.value) {
    scrollContainer.value.addEventListener('scroll', throttledScroll, { passive: true })
  }
})

onUnmounted(() => {
  window.removeEventListener('resize', updateContainerHeight)
  
  if (scrollTimeout) {
    cancelAnimationFrame(scrollTimeout)
  }
})

// ç›£è½é …ç›®è®ŠåŒ–
watch(() => props.items, () => {
  scrollTop.value = scrollContainer.value?.scrollTop || 0
}, { flush: 'post' })

defineExpose({
  scrollToItem
})
</script>

<style scoped>
.virtual-scroll-container {
  @apply relative overflow-auto;
  height: v-bind(containerHeight + 'px');
}

.spacer {
  @apply w-full;
}

.virtual-item {
  @apply absolute left-0 right-0;
}
</style>
```

### çµ„ä»¶è¨˜æ†¶åŒ–å„ªåŒ–
```typescript
// composables/useComponentMemo.ts
import { ref, computed, watch, shallowRef } from 'vue'

interface MemoOptions<T> {
  // æ¯”è¼ƒå‡½æ•¸ï¼Œè¿”å› true è¡¨ç¤ºç›¸ç­‰
  compare?: (prev: T, next: T) => boolean
  // å¿«å–å¤§å°é™åˆ¶
  cacheSize?: number
  // å¿«å–éµç”Ÿæˆå‡½æ•¸
  keyGenerator?: (props: T) => string
}

export const useComponentMemo = <T extends Record<string, any>>(
  component: any,
  options: MemoOptions<T> = {}
) => {
  const cache = new Map<string, { component: any; props: T }>()
  const {
    compare = shallowEqual,
    cacheSize = 50,
    keyGenerator = defaultKeyGenerator
  } = options
  
  return computed(() => {
    return (props: T) => {
      const key = keyGenerator(props)
      const cached = cache.get(key)
      
      // æª¢æŸ¥å¿«å–æ˜¯å¦å‘½ä¸­ä¸” props ç›¸ç­‰
      if (cached && compare(cached.props, props)) {
        return cached.component
      }
      
      // å‰µå»ºæ–°çš„çµ„ä»¶å¯¦ä¾‹
      const memoizedComponent = shallowRef(component)
      
      // æ›´æ–°å¿«å–
      cache.set(key, { component: memoizedComponent, props })
      
      // é™åˆ¶å¿«å–å¤§å°
      if (cache.size > cacheSize) {
        const firstKey = cache.keys().next().value
        cache.delete(firstKey)
      }
      
      return memoizedComponent
    }
  })
}

// æ·ºæ¯”è¼ƒå‡½æ•¸
const shallowEqual = <T extends Record<string, any>>(a: T, b: T): boolean => {
  const keysA = Object.keys(a)
  const keysB = Object.keys(b)
  
  if (keysA.length !== keysB.length) {
    return false
  }
  
  return keysA.every(key => a[key] === b[key])
}

// é è¨­éµç”Ÿæˆå™¨
const defaultKeyGenerator = <T extends Record<string, any>>(props: T): string => {
  return JSON.stringify(props)
}

// React.memo é¢¨æ ¼çš„çµ„ä»¶åŒ…è£å™¨
export const memo = <T extends Record<string, any>>(
  component: any,
  compare?: (prev: T, next: T) => boolean
) => {
  const memoizedComponent = useComponentMemo(component, { compare })
  
  return (props: T) => memoizedComponent.value(props)
}

// ä½¿ç”¨ç¯„ä¾‹
export const useMemoizedScoreCard = () => {
  return memo(
    // çµ„ä»¶
    () => import('../components/ScoreCard.vue'),
    // æ¯”è¼ƒå‡½æ•¸
    (prevProps, nextProps) => {
      return prevProps.score.id === nextProps.score.id &&
             prevProps.score.updatedAt === nextProps.score.updatedAt
    }
  )
}
```

---

## ğŸ’¾ æ•¸æ“šèˆ‡ç‹€æ…‹å„ªåŒ–

### æ™ºèƒ½ç‹€æ…‹ç®¡ç†
```typescript
// stores/optimizedStore.ts
import { defineStore } from 'pinia'
import { ref, computed, watch } from 'vue'

interface OptimizedState {
  // ä½¿ç”¨ Map æ›¿ä»£ Object ä»¥æå‡æŸ¥æ‰¾æ€§èƒ½
  scores: Map<string, Score>
  selectedScores: Set<string>
  // åˆ†é è³‡æ–™
  scorePages: Map<number, string[]>
  currentPage: number
  // å¿«å–çµ±è¨ˆ
  cacheStats: {
    hits: number
    misses: number
    size: number
  }
}

export const useOptimizedStore = defineStore('optimized', () => {
  // ç‹€æ…‹
  const state = ref<OptimizedState>({
    scores: new Map(),
    selectedScores: new Set(),
    scorePages: new Map(),
    currentPage: 1,
    cacheStats: {
      hits: 0,
      misses: 0,
      size: 0
    }
  })
  
  // è¨ˆç®—å±¬æ€§ - ä½¿ç”¨è¨˜æ†¶åŒ–é¿å…é‡è¤‡è¨ˆç®—
  const currentPageScores = computed(() => {
    const scoreIds = state.value.scorePages.get(state.value.currentPage)
    if (!scoreIds) return []
    
    return scoreIds
      .map(id => state.value.scores.get(id))
      .filter(Boolean) as Score[]
  })
  
  const selectedScoresList = computed(() => {
    return Array.from(state.value.selectedScores)
      .map(id => state.value.scores.get(id))
      .filter(Boolean) as Score[]
  })
  
  // æ‰¹é‡æ“ä½œ - æ¸›å°‘éŸ¿æ‡‰å¼æ›´æ–°æ¬¡æ•¸
  const batchUpdateScores = (scores: Score[]) => {
    // æš«åœéŸ¿æ‡‰å¼æ›´æ–°
    const originalScores = state.value.scores
    const newScores = new Map(originalScores)
    
    // æ‰¹é‡æ›´æ–°
    scores.forEach(score => {
      newScores.set(score.id, score)
    })
    
    // ä¸€æ¬¡æ€§æ›´æ–°
    state.value.scores = newScores
    state.value.cacheStats.size = newScores.size
  }
  
  // æ™ºèƒ½å¿«å– - LRU å¿«å–ç­–ç•¥
  const scoreCache = new Map<string, { data: Score; accessTime: number }>()
  const MAX_CACHE_SIZE = 100
  
  const getScoreFromCache = (id: string): Score | null => {
    const cached = scoreCache.get(id)
    
    if (cached) {
      // æ›´æ–°å­˜å–æ™‚é–“
      cached.accessTime = Date.now()
      state.value.cacheStats.hits++
      return cached.data
    }
    
    state.value.cacheStats.misses++
    return null
  }
  
  const setScoreToCache = (score: Score) => {
    // æª¢æŸ¥å¿«å–å¤§å°
    if (scoreCache.size >= MAX_CACHE_SIZE) {
      // ç§»é™¤æœ€ä¹…æœªå­˜å–çš„é …ç›®
      let oldestKey = ''
      let oldestTime = Date.now()
      
      scoreCache.forEach((value, key) => {
        if (value.accessTime < oldestTime) {
          oldestTime = value.accessTime
          oldestKey = key
        }
      })
      
      if (oldestKey) {
        scoreCache.delete(oldestKey)
      }
    }
    
    scoreCache.set(score.id, {
      data: score,
      accessTime: Date.now()
    })
  }
  
  // é˜²æŠ–æ“ä½œ - é¿å…é »ç¹APIè«‹æ±‚
  const debouncedSearch = debounce((query: string) => {
    return searchScores(query)
  }, 300)
  
  // é¸å–ç‹€æ…‹å„ªåŒ– - ä½¿ç”¨ Set æå‡æ€§èƒ½
  const toggleScoreSelection = (scoreId: string) => {
    const newSelection = new Set(state.value.selectedScores)
    
    if (newSelection.has(scoreId)) {
      newSelection.delete(scoreId)
    } else {
      newSelection.add(scoreId)
    }
    
    state.value.selectedScores = newSelection
  }
  
  const selectAllScores = (scoreIds: string[]) => {
    state.value.selectedScores = new Set([
      ...state.value.selectedScores,
      ...scoreIds
    ])
  }
  
  const clearSelection = () => {
    state.value.selectedScores = new Set()
  }
  
  // è¨˜æ†¶é«”æ¸…ç†
  const cleanup = () => {
    // æ¸…ç†å¿«å–
    scoreCache.clear()
    
    // é‡ç½®çµ±è¨ˆ
    state.value.cacheStats = {
      hits: 0,
      misses: 0,
      size: state.value.scores.size
    }
  }
  
  // ç›£è½å™¨å„ªåŒ– - ä½¿ç”¨ shallow ç›£è½
  watch(
    () => state.value.scores.size,
    (newSize) => {
      state.value.cacheStats.size = newSize
    }
  )
  
  return {
    // ç‹€æ…‹
    state: readonly(state),
    
    // è¨ˆç®—å±¬æ€§
    currentPageScores,
    selectedScoresList,
    
    // æ“ä½œæ–¹æ³•
    batchUpdateScores,
    getScoreFromCache,
    setScoreToCache,
    toggleScoreSelection,
    selectAllScores,
    clearSelection,
    debouncedSearch,
    cleanup
  }
})

// é˜²æŠ–å·¥å…·å‡½æ•¸
function debounce<T extends (...args: any[]) => any>(
  func: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timeoutId: number
  
  return (...args: Parameters<T>) => {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => func(...args), delay)
  }
}

// ç¯€æµå·¥å…·å‡½æ•¸
function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle: boolean
  
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func(...args)
      inThrottle = true
      setTimeout(() => inThrottle = false, limit)
    }
  }
}
```

### æœ¬åœ°å„²å­˜å„ªåŒ–
```typescript
// utils/storage.ts
interface StorageItem<T> {
  value: T
  expiry?: number
  version?: number
}

class OptimizedStorage {
  private prefix: string
  private maxSize: number
  private compressionThreshold: number
  
  constructor(prefix = 'bandpro_', maxSize = 5 * 1024 * 1024, compressionThreshold = 1024) {
    this.prefix = prefix
    this.maxSize = maxSize
    this.compressionThreshold = compressionThreshold
  }
  
  // è¨­å®šé …ç›®
  set<T>(key: string, value: T, expiryMs?: number): boolean {
    try {
      const item: StorageItem<T> = {
        value,
        expiry: expiryMs ? Date.now() + expiryMs : undefined,
        version: 1
      }
      
      let serialized = JSON.stringify(item)
      
      // å£“ç¸®å¤§å‹è³‡æ–™
      if (serialized.length > this.compressionThreshold) {
        serialized = this.compress(serialized)
      }
      
      // æª¢æŸ¥å„²å­˜ç©ºé–“
      if (this.getStorageSize() + serialized.length > this.maxSize) {
        this.cleanup()
      }
      
      localStorage.setItem(this.prefix + key, serialized)
      return true
      
    } catch (error) {
      console.error('å„²å­˜å¤±æ•—:', error)
      return false
    }
  }
  
  // ç²å–é …ç›®
  get<T>(key: string, defaultValue?: T): T | undefined {
    try {
      const item = localStorage.getItem(this.prefix + key)
      if (!item) return defaultValue
      
      let parsed: StorageItem<T>
      
      // æª¢æŸ¥æ˜¯å¦ç‚ºå£“ç¸®è³‡æ–™
      if (item.startsWith('compressed:')) {
        const decompressed = this.decompress(item)
        parsed = JSON.parse(decompressed)
      } else {
        parsed = JSON.parse(item)
      }
      
      // æª¢æŸ¥éæœŸæ™‚é–“
      if (parsed.expiry && Date.now() > parsed.expiry) {
        this.remove(key)
        return defaultValue
      }
      
      return parsed.value
      
    } catch (error) {
      console.error('è®€å–å¤±æ•—:', error)
      return defaultValue
    }
  }
  
  // ç§»é™¤é …ç›®
  remove(key: string): void {
    localStorage.removeItem(this.prefix + key)
  }
  
  // æ¸…ç©ºæ‰€æœ‰é …ç›®
  clear(): void {
    const keys = Object.keys(localStorage)
    keys.forEach(key => {
      if (key.startsWith(this.prefix)) {
        localStorage.removeItem(key)
      }
    })
  }
  
  // ç²å–å„²å­˜å¤§å°
  private getStorageSize(): number {
    let size = 0
    const keys = Object.keys(localStorage)
    
    keys.forEach(key => {
      if (key.startsWith(this.prefix)) {
        size += localStorage.getItem(key)?.length || 0
      }
    })
    
    return size
  }
  
  // æ¸…ç†éæœŸé …ç›®
  private cleanup(): void {
    const keys = Object.keys(localStorage)
    const now = Date.now()
    
    keys.forEach(key => {
      if (key.startsWith(this.prefix)) {
        try {
          const item = localStorage.getItem(key)
          if (item) {
            const parsed: StorageItem<any> = JSON.parse(item)
            if (parsed.expiry && now > parsed.expiry) {
              localStorage.removeItem(key)
            }
          }
        } catch (error) {
          // ç§»é™¤æå£çš„é …ç›®
          localStorage.removeItem(key)
        }
      }
    })
  }
  
  // ç°¡å–®å£“ç¸®ï¼ˆå¯¦éš›æ‡‰ç”¨ä¸­å¯ä½¿ç”¨æ›´å¥½çš„å£“ç¸®ç®—æ³•ï¼‰
  private compress(data: string): string {
    try {
      // ä½¿ç”¨ç°¡å–®çš„ RLE å£“ç¸®æˆ–è€… LZ å£“ç¸®
      return 'compressed:' + btoa(data)
    } catch (error) {
      return data
    }
  }
  
  // è§£å£“ç¸®
  private decompress(data: string): string {
    try {
      return atob(data.replace('compressed:', ''))
    } catch (error) {
      return data
    }
  }
  
  // æ‰¹é‡æ“ä½œ
  setBatch<T>(items: Array<{ key: string; value: T; expiryMs?: number }>): void {
    items.forEach(item => {
      this.set(item.key, item.value, item.expiryMs)
    })
  }
  
  getBatch<T>(keys: string[]): Array<T | undefined> {
    return keys.map(key => this.get<T>(key))
  }
  
  // ç²å–å„²å­˜çµ±è¨ˆ
  getStats(): {
    totalSize: number
    itemCount: number
    expiredCount: number
  } {
    const keys = Object.keys(localStorage)
    let totalSize = 0
    let itemCount = 0
    let expiredCount = 0
    const now = Date.now()
    
    keys.forEach(key => {
      if (key.startsWith(this.prefix)) {
        itemCount++
        const item = localStorage.getItem(key)
        if (item) {
          totalSize += item.length
          
          try {
            const parsed: StorageItem<any> = JSON.parse(item)
            if (parsed.expiry && now > parsed.expiry) {
              expiredCount++
            }
          } catch (error) {
            // å¿½ç•¥è§£æéŒ¯èª¤
          }
        }
      }
    })
    
    return { totalSize, itemCount, expiredCount }
  }
}

// å°å‡ºå–®ä¾‹å¯¦ä¾‹
export const storage = new OptimizedStorage()

// å°ˆç”¨å¿«å–é¡åˆ¥
export class CacheManager<T> {
  private storage: OptimizedStorage
  private namespace: string
  
  constructor(namespace: string) {
    this.storage = storage
    this.namespace = namespace
  }
  
  async get(key: string): Promise<T | null> {
    return this.storage.get<T>(`${this.namespace}:${key}`) || null
  }
  
  async set(key: string, value: T, ttl = 3600000): Promise<void> {
    this.storage.set(`${this.namespace}:${key}`, value, ttl)
  }
  
  async delete(key: string): Promise<void> {
    this.storage.remove(`${this.namespace}:${key}`)
  }
  
  async clear(): Promise<void> {
    const keys = Object.keys(localStorage)
    keys.forEach(key => {
      if (key.startsWith(`${this.storage['prefix']}${this.namespace}:`)) {
        localStorage.removeItem(key)
      }
    })
  }
}

// ä½¿ç”¨ç¯„ä¾‹
export const scoreCache = new CacheManager<Score>('scores')
export const userCache = new CacheManager<User>('users')
export const settingsCache = new CacheManager<Settings>('settings')
```

---

## ğŸ“Š æ€§èƒ½ç›£æ§èˆ‡åˆ†æ

### æ€§èƒ½æŒ‡æ¨™æ”¶é›†
```typescript
// utils/performanceMonitor.ts
interface PerformanceMetrics {
  // Core Web Vitals
  LCP?: number  // Largest Contentful Paint
  FID?: number  // First Input Delay
  CLS?: number  // Cumulative Layout Shift
  FCP?: number  // First Contentful Paint
  TTFB?: number // Time to First Byte
  
  // è‡ªè¨‚æŒ‡æ¨™
  routeChangeTime?: number
  componentRenderTime?: number
  apiResponseTime?: number
  memoryUsage?: number
  
  // ä½¿ç”¨è€…äº’å‹•
  userInteractions?: number
  errorCount?: number
}

class PerformanceMonitor {
  private metrics: PerformanceMetrics = {}
  private observers: PerformanceObserver[] = []
  
  constructor() {
    this.initializeObservers()
  }
  
  private initializeObservers() {
    // Web Vitals ç›£æ§
    this.observeWebVitals()
    
    // è·¯ç”±è®Šæ›´ç›£æ§
    this.observeRouteChanges()
    
    // è¨˜æ†¶é«”ä½¿ç”¨ç›£æ§
    this.observeMemoryUsage()
    
    // ç¶²è·¯è«‹æ±‚ç›£æ§
    this.observeNetworkRequests()
  }
  
  private observeWebVitals() {
    // LCP ç›£æ§
    const lcpObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries()
      const lastEntry = entries[entries.length - 1] as PerformanceEntry
      this.metrics.LCP = lastEntry.startTime
    })
    lcpObserver.observe({ type: 'largest-contentful-paint', buffered: true })
    this.observers.push(lcpObserver)
    
    // FID ç›£æ§
    const fidObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries() as PerformanceEventTiming[]
      entries.forEach(entry => {
        this.metrics.FID = entry.processingStart - entry.startTime
      })
    })
    fidObserver.observe({ type: 'first-input', buffered: true })
    this.observers.push(fidObserver)
    
    // CLS ç›£æ§
    let clsValue = 0
    const clsObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries() as LayoutShift[]
      entries.forEach(entry => {
        if (!entry.hadRecentInput) {
          clsValue += entry.value
        }
      })
      this.metrics.CLS = clsValue
    })
    clsObserver.observe({ type: 'layout-shift', buffered: true })
    this.observers.push(clsObserver)
  }
  
  private observeRouteChanges() {
    let routeStartTime = Date.now()
    
    // ç›£è½è·¯ç”±è®Šæ›´
    window.addEventListener('beforeunload', () => {
      routeStartTime = Date.now()
    })
    
    window.addEventListener('load', () => {
      this.metrics.routeChangeTime = Date.now() - routeStartTime
    })
  }
  
  private observeMemoryUsage() {
    // å®šæœŸæ”¶é›†è¨˜æ†¶é«”ä½¿ç”¨æƒ…æ³
    setInterval(() => {
      if ('memory' in performance) {
        const memory = (performance as any).memory
        this.metrics.memoryUsage = memory.usedJSHeapSize / memory.totalJSHeapSize
      }
    }, 30000) // æ¯ 30 ç§’æ”¶é›†ä¸€æ¬¡
  }
  
  private observeNetworkRequests() {
    const resourceObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries() as PerformanceResourceTiming[]
      entries.forEach(entry => {
        if (entry.name.includes('/api/')) {
          this.metrics.apiResponseTime = entry.responseEnd - entry.requestStart
        }
      })
    })
    resourceObserver.observe({ type: 'resource', buffered: true })
    this.observers.push(resourceObserver)
  }
  
  // æ¨™è¨˜è‡ªè¨‚æ•ˆèƒ½æŒ‡æ¨™
  mark(name: string) {
    performance.mark(name)
  }
  
  // æ¸¬é‡æ™‚é–“é–“éš”
  measure(name: string, startMark: string, endMark?: string) {
    performance.measure(name, startMark, endMark)
    
    const measures = performance.getEntriesByName(name, 'measure')
    const lastMeasure = measures[measures.length - 1]
    
    return lastMeasure.duration
  }
  
  // æ”¶é›†çµ„ä»¶æ¸²æŸ“æ™‚é–“
  measureComponentRender<T>(componentName: string, renderFn: () => T): T {
    const startMark = `${componentName}-render-start`
    const endMark = `${componentName}-render-end`
    
    this.mark(startMark)
    const result = renderFn()
    this.mark(endMark)
    
    const duration = this.measure(`${componentName}-render`, startMark, endMark)
    this.metrics.componentRenderTime = duration
    
    return result
  }
  
  // æ”¶é›†ç”¨æˆ¶äº’å‹•æŒ‡æ¨™
  recordUserInteraction(type: string) {
    this.metrics.userInteractions = (this.metrics.userInteractions || 0) + 1
    
    // è¨˜éŒ„äº’å‹•é¡å‹å’Œæ™‚é–“
    this.mark(`interaction-${type}-${Date.now()}`)
  }
  
  // æ”¶é›†éŒ¯èª¤æŒ‡æ¨™
  recordError(error: Error) {
    this.metrics.errorCount = (this.metrics.errorCount || 0) + 1
    
    // å¯ä»¥ç™¼é€éŒ¯èª¤è³‡è¨Šåˆ°ç›£æ§æœå‹™
    console.error('æ•ˆèƒ½ç›£æ§ - éŒ¯èª¤è¨˜éŒ„:', error)
  }
  
  // ç²å–ç•¶å‰æŒ‡æ¨™
  getMetrics(): PerformanceMetrics {
    return { ...this.metrics }
  }
  
  // ç™¼é€æŒ‡æ¨™åˆ°ç›£æ§æœå‹™
  async sendMetrics() {
    try {
      await fetch('/api/metrics', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          metrics: this.metrics,
          timestamp: Date.now(),
          userAgent: navigator.userAgent,
          url: window.location.href
        })
      })
    } catch (error) {
      console.error('ç™¼é€æ€§èƒ½æŒ‡æ¨™å¤±æ•—:', error)
    }
  }
  
  // ç”Ÿæˆæ€§èƒ½å ±å‘Š
  generateReport(): string {
    const report = []
    
    // Core Web Vitals è©•ç´š
    if (this.metrics.LCP) {
      const lcpGrade = this.metrics.LCP < 2500 ? 'Good' : 
                       this.metrics.LCP < 4000 ? 'Needs Improvement' : 'Poor'
      report.push(`LCP: ${this.metrics.LCP.toFixed(2)}ms (${lcpGrade})`)
    }
    
    if (this.metrics.FID) {
      const fidGrade = this.metrics.FID < 100 ? 'Good' : 
                       this.metrics.FID < 300 ? 'Needs Improvement' : 'Poor'
      report.push(`FID: ${this.metrics.FID.toFixed(2)}ms (${fidGrade})`)
    }
    
    if (this.metrics.CLS) {
      const clsGrade = this.metrics.CLS < 0.1 ? 'Good' : 
                       this.metrics.CLS < 0.25 ? 'Needs Improvement' : 'Poor'
      report.push(`CLS: ${this.metrics.CLS.toFixed(3)} (${clsGrade})`)
    }
    
    // å…¶ä»–æŒ‡æ¨™
    if (this.metrics.routeChangeTime) {
      report.push(`Route Change: ${this.metrics.routeChangeTime}ms`)
    }
    
    if (this.metrics.componentRenderTime) {
      report.push(`Component Render: ${this.metrics.componentRenderTime.toFixed(2)}ms`)
    }
    
    if (this.metrics.memoryUsage) {
      report.push(`Memory Usage: ${(this.metrics.memoryUsage * 100).toFixed(1)}%`)
    }
    
    return report.join('\n')
  }
  
  // æ¸…ç†è§€å¯Ÿè€…
  cleanup() {
    this.observers.forEach(observer => observer.disconnect())
    this.observers = []
  }
}

// å°å‡ºå–®ä¾‹å¯¦ä¾‹
export const performanceMonitor = new PerformanceMonitor()

// Vue æ’ä»¶
export const PerformancePlugin = {
  install(app: any) {
    // å…¨åŸŸå±¬æ€§
    app.config.globalProperties.$performance = performanceMonitor
    
    // è·¯ç”±å®ˆè¡›
    if (app.config.globalProperties.$router) {
      app.config.globalProperties.$router.beforeEach(() => {
        performanceMonitor.mark('route-start')
      })
      
      app.config.globalProperties.$router.afterEach(() => {
        performanceMonitor.mark('route-end')
        performanceMonitor.measure('route-change', 'route-start', 'route-end')
      })
    }
    
    // éŒ¯èª¤è™•ç†
    app.config.errorHandler = (error: Error) => {
      performanceMonitor.recordError(error)
    }
  }
}
```

---

## âœ… æœ¬æ–‡ä»¶åŒ…å«å…§å®¹

1. **æ€§èƒ½å„ªåŒ–æ¶æ§‹** - è¼‰å…¥ã€æ¸²æŸ“ã€æ•¸æ“šã€ç¶²è·¯å››å±¤å„ªåŒ–ç­–ç•¥
2. **è¼‰å…¥æ€§èƒ½å„ªåŒ–** - æ‡¶è¼‰å…¥ã€ä»£ç¢¼åˆ†å‰²ã€è³‡æºé è¼‰å…¥å¯¦ç¾
3. **æ¸²æŸ“æ€§èƒ½å„ªåŒ–** - è™›æ“¬æ»¾å‹•ã€çµ„ä»¶è¨˜æ†¶åŒ–ã€DOMå„ªåŒ–
4. **æ•¸æ“šèˆ‡ç‹€æ…‹å„ªåŒ–** - æ™ºèƒ½ç‹€æ…‹ç®¡ç†ã€æœ¬åœ°å„²å­˜ã€å¿«å–ç­–ç•¥
5. **æ€§èƒ½ç›£æ§èˆ‡åˆ†æ** - Core Web Vitalsç›£æ§ã€è‡ªè¨‚æŒ‡æ¨™æ”¶é›†

## ğŸ¯ UIè¨­è¨ˆæ–‡ä»¶ç³»åˆ—å®Œæˆ

å·²å®Œæˆæ•´å¥— BandPro UI/UX è¨­è¨ˆæ–‡ä»¶ï¼š

1. **00_UIè¨­è¨ˆç¸½è¦½èˆ‡æŒ‡å°åŸå‰‡** - è¨­è¨ˆåŸå‰‡ã€ç”¨æˆ¶ç¾¤ã€ä¸»é¡Œç­–ç•¥
2. **01_è¨­è¨ˆç³»çµ±èˆ‡çµ„ä»¶åº«** - è¨­è¨ˆä»£å¹£ã€çµ„ä»¶è¦ç¯„ã€éŸ³æ¨‚å°ˆç”¨çµ„ä»¶
3. **02_ä¸»é¡Œç³»çµ±èˆ‡è‰²å½©è¦ç¯„** - æ·±æ·ºè‰²ä¸»é¡Œã€è‰²å½©è¦ç¯„ã€ä¸»é¡Œåˆ‡æ›
4. **03_éŸ¿æ‡‰å¼ä½ˆå±€è¨­è¨ˆ** - æ–·é»ç³»çµ±ã€ä½ˆå±€ç­–ç•¥ã€éŸ³æ¨‚å°ˆç”¨éŸ¿æ‡‰å¼
5. **04_å°èˆªç³»çµ±è¨­è¨ˆ** - å¤šå±¤å°èˆªã€éŸ¿æ‡‰å¼å°èˆªã€æœå°‹ç³»çµ±
6. **05_é é¢ä½ˆå±€è¨­è¨ˆ** - é¦–é ã€ç·¨è¼¯å™¨ä½ˆå±€æ¶æ§‹
7. **06_ç·¨è¼¯å™¨ç•Œé¢è¨­è¨ˆ** - å·¥å…·é¢æ¿ã€æ¨‚è­œç•«å¸ƒã€éŸ³ç¬¦ç·¨è¼¯
8. **07_æ¨‚åº«èˆ‡å”ä½œç•Œé¢** - æ¨‚è­œç®¡ç†ã€ç€è¦½ç•Œé¢ã€æ¨‚è­œå¡ç‰‡
9. **08_ç”¨æˆ¶ç³»çµ±ç•Œé¢** - ç™»å…¥è¨»å†Šã€å€‹äººæª”æ¡ˆã€æ¬Šé™ç®¡ç†
10. **09_ç„¡éšœç¤™è¨­è¨ˆè¦ç¯„** - WCAG 2.1 AAã€éµç›¤å°èˆªã€è¢å¹•é–±è®€å™¨
11. **10_æ€§èƒ½å„ªåŒ–è¨­è¨ˆ** - è¼‰å…¥å„ªåŒ–ã€æ¸²æŸ“å„ªåŒ–ã€æ€§èƒ½ç›£æ§

é€™å¥—å®Œæ•´çš„ UI/UX è¨­è¨ˆæ–‡ä»¶ç‚º BandPro æ¨‚åœ˜å”ä½œæ‰“è­œç³»çµ±æä¾›äº†ï¼š
- âœ… **ç¾ä»£åŒ–è¨­è¨ˆ** - Vue 3 + TypeScript + Tailwind CSS
- âœ… **éŸ¿æ‡‰å¼æ”¯æ´** - æ¡Œé¢/å¹³æ¿/æ‰‹æ©Ÿå®Œæ•´é©é…
- âœ… **ä¸»é¡Œåˆ‡æ›** - æ·±è‰²/æ·ºè‰²æ¨¡å¼ç„¡ç¸«åˆ‡æ›
- âœ… **ç„¡éšœç¤™å‹å¥½** - ç¬¦åˆåœ‹éš›æ¨™æº–çš„ç„¡éšœç¤™è¨­è¨ˆ
- âœ… **æ€§èƒ½å„ªåŒ–** - å®Œæ•´çš„å‰ç«¯æ€§èƒ½å„ªåŒ–ç­–ç•¥
- âœ… **éŸ³æ¨‚å°ˆæ¥­** - é‡å°éŸ³æ¨‚ç·¨è¼¯å ´æ™¯çš„å°ˆæ¥­è¨­è¨ˆ
